---
# This playbook requires a data structure like this
# in order to execute:
#
# instance_list:
#   - name: instance1
#     flavor: general1-1
#     region: DFW
#     state: present
#     metadata:
#       group: mygroup
#
# Additionally, you can optionally specify volumes
# to be created and attached:
#
# instance_list:
#   - name: instance1
#     flavor: general1-1
#     region: DFW
#     state: present
#     volumes:
#       - name: vol1
#         device: /dev/xvde
#         type: SATA
#         size: 1024
#         state: present
#     metadata:
#       group: mygroup
#

- name: Create/delete OpenStack Instances
  hosts: localhost
  connection: local
  gather_facts: False
  vars:
    default_metadata:
      # NOTE(odyssey4me):
      # There is a build_config option to have MaaS setup
      # by the public cloud automation when the instance
      # is being built, but that option will not be available
      # in Phobos, so we'll rather do it using our MaaS
      # deployment tooling.
      build_config: core
  tasks:
    - name: Unlock instances scheduled to be deleted or where volumes may need to be added
      os_server_action:
        action: unlock
        server: "{{ instance['name'] | lower }}"
        cloud: "{{ cloud_name | default('public_cloud') }}"
        region_name: "{{ instance['region'] | default('IAD') }}"
        wait: yes
        timeout: 900
      when:
        - instance['name'] in groups['all']
        - (instance['state'] | default('present') == 'absent' or (instance['state'] | default('present') == 'present' and 'volumes' in instance))
      loop: "{{ (instance_list | default([])) | flatten(levels=1) }}"
      loop_control:
        loop_var: instance

    - name: Create/delete OpenStack Instances
      os_server:
        # We use lower case for the instance name
        # so that the server name matches the DNS
        # name when the server comes up.
        name: "{{ instance['name'] | lower }}"
        flavor: "{{ instance['flavor'] | default('general1-8') }}"
        state: "{{ instance['state'] | default('present') }}"
        cloud: "{{ cloud_name | default('public_cloud') }}"
        region_name: "{{ instance['region'] | default('IAD') }}"
        image: "{{ instance['image'] | default('Ubuntu 16.04 LTS (Xenial Xerus) (PVHVM)') }}"
        key_name: "{{ keyname | default('jenkins') }}"
        security_groups: []
        userdata: "{{ instance['userdata'] | default(omit) }}"
        config_drive: yes
        meta: "{{ default_metadata | combine(instance['metadata'] | default({})) }}"
        wait: yes
        timeout: 900
      loop: "{{ (instance_list | default([])) | flatten(levels=1) }}"
      loop_control:
        loop_var: instance

    - name: Create data volumes
      os_volume:
        display_name: "{{ item[1]['name'] }}"
        volume_type: "{{ item[1]['type'] }}"
        size: "{{ item[1]['size'] }}"
        state: present
        cloud: "{{ cloud_name | default('public_cloud') }}"
        region_name: "{{ item[0]['region'] }}"
        wait: yes
        timeout: 900
      when:
        - item[0]['state'] | default('present') != 'absent'
      loop: "{{ (instance_list | default([])) | subelements('volumes', skip_missing=True) }}"

    - name: Delete data volumes on deleted instances
      os_volume:
        display_name: "{{ item[1]['name'] }}"
        volume_type: "{{ item[1]['type'] }}"
        size: "{{ item[1]['size'] }}"
        state: absent
        cloud: "{{ cloud_name | default('public_cloud') }}"
        region_name: "{{ item[0]['region'] }}"
        wait: yes
        timeout: 900
      when:
        - item[0]['state'] | default('present') == 'absent'
        - item[1]['state'] | default('present') == 'absent'
      loop: "{{ (instance_list | default([])) | subelements('volumes', skip_missing=True) }}"

    # NOTE(mattt):
    # At present we do not support detaching / deleting volumes attached to a
    # running instance. We'd need to do some poking around inside the instance
    # to check if the disk is in use before we know it's safe to detach /
    # delete, and this will require a bunch more testing.
    - name: Attach the data volumes
      os_server_volume:
        server: "{{ item[0]['name'] }}"
        volume: "{{ item[1]['name'] }}"
        device: "{{ item[1]['device'] }}"
        state: present
        cloud: "{{ cloud_name | default('public_cloud') }}"
        region_name: "{{ item[0]['region'] }}"
        wait: yes
        timeout: 900
      when:
        - item[0]['state'] | default('present') != 'absent' and item[1]['state'] | default('present') != 'absent'
      loop: "{{ (instance_list | default([])) | subelements('volumes', skip_missing=True) }}"

    - name: Refresh dynamic inventory for any changes made
      meta: refresh_inventory

    - name: Lock instances to prevent accidental deletion
      os_server_action:
        action: lock
        server: "{{ instance['name'] | lower }}"
        cloud: "{{ cloud_name | default('public_cloud') }}"
        region_name: "{{ instance['region'] | default('IAD') }}"
        wait: yes
        timeout: 900
      when:
        - instance['name'] in groups['all']
      loop: "{{ (instance_list | default([])) | flatten(levels=1) }}"
      loop_control:
        loop_var: instance

    - name: Add new hosts to bootstrap group
      add_host:
        name: "{{ item }}"
        groups: new_hosts_to_bootstrap
      loop: >-
        {{
          (instance_list | selectattr('state', 'defined') | selectattr('state', 'equalto', 'present') | map(attribute='name') | list) +
          (instance_list | selectattr('state', 'undefined') | map(attribute='name') | list)
        }}

# Note(odyssey4me):
# At this stage, Ansible may not be able to gather facts
# because python is not present on the target host. We
# therefore do not gather facts and have to use the raw
# or script module only to get the pre-requisites installed.
- name: Install Ansible prerequisites
  hosts: new_hosts_to_bootstrap
  gather_facts: no
  user: root
  tasks:
    - name: Ensure python is installed
      raw: |
        set -e
        if which apt-get >/dev/null && ! which python >/dev/null ; then
          apt-get update
          apt-get -y install python
          exit 2
        else
          exit 0
        fi
      args:
        executable: /bin/bash
        warn: no
      register: result
      changed_when: "result.rc == 2"
      failed_when: "result.rc not in [0, 2]"
